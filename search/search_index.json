{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Integrations SDK Lean batteries-included integrations built to accelerate agent development. Highlights Providers auto-configure from env vars and expose common async actions. A shared Integrations container keeps lookup, scope, and overrides simple. Optional auth subsystem wires auth flows (like OAuth2) to provider settings. Async first! Read Next Getting Started Provider Catalog Auth Overview","title":"Overview"},{"location":"#integrations-sdk","text":"Lean batteries-included integrations built to accelerate agent development.","title":"Integrations SDK"},{"location":"#highlights","text":"Providers auto-configure from env vars and expose common async actions. A shared Integrations container keeps lookup, scope, and overrides simple. Optional auth subsystem wires auth flows (like OAuth2) to provider settings. Async first!","title":"Highlights"},{"location":"#read-next","text":"Getting Started Provider Catalog Auth Overview","title":"Read Next"},{"location":"getting-started/","text":"Getting Started Install uv add \"integrations @ git+https://github.com/anishxyz/integrations\" Configure Set provider env vars or pass settings into the container. Example GitHub token: export GITHUB_TOKEN=ghp_example_token First Call import asyncio from integrations import Integrations async def main() -> None: integrations = Integrations() repo = await integrations.github.find_repository( owner=\"octocat\", name=\"Hello-World\", ) print(repo[\"full_name\"]) asyncio.run(main()) This works because GithubSettings.token reads GITHUB_TOKEN . Pass explicit overrides when you need something custom: integrations = Integrations( github={\"token\": \"...\", \"user_agent\": \"integrations-demo\"}, )","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#install","text":"uv add \"integrations @ git+https://github.com/anishxyz/integrations\"","title":"Install"},{"location":"getting-started/#configure","text":"Set provider env vars or pass settings into the container. Example GitHub token: export GITHUB_TOKEN=ghp_example_token","title":"Configure"},{"location":"getting-started/#first-call","text":"import asyncio from integrations import Integrations async def main() -> None: integrations = Integrations() repo = await integrations.github.find_repository( owner=\"octocat\", name=\"Hello-World\", ) print(repo[\"full_name\"]) asyncio.run(main()) This works because GithubSettings.token reads GITHUB_TOKEN . Pass explicit overrides when you need something custom: integrations = Integrations( github={\"token\": \"...\", \"user_agent\": \"integrations-demo\"}, )","title":"First Call"},{"location":"provider-catalog/","text":"Provider Catalog Providers are first-party integrations. They expose common actions and can be configured with their respective settings. integrations.github \u2192 GitHub integrations.gmail \u2192 Gmail integrations.google_calendar \u2192 Google Calendar integrations.google_docs \u2192 Google Docs integrations.google_drive \u2192 Google Drive integrations.google_sheets \u2192 Google Sheets integrations.asana \u2192 Asana integrations.hubspot \u2192 HubSpot integrations.notion \u2192 Notion integrations.slack \u2192 Slack","title":"Catalog"},{"location":"provider-catalog/#provider-catalog","text":"Providers are first-party integrations. They expose common actions and can be configured with their respective settings. integrations.github \u2192 GitHub integrations.gmail \u2192 Gmail integrations.google_calendar \u2192 Google Calendar integrations.google_docs \u2192 Google Docs integrations.google_drive \u2192 Google Drive integrations.google_sheets \u2192 Google Sheets integrations.asana \u2192 Asana integrations.hubspot \u2192 HubSpot integrations.notion \u2192 Notion integrations.slack \u2192 Slack","title":"Provider Catalog"},{"location":"auth/","text":"Auth Overview The auth subsystem keeps provider-specific credential logic out of your application code. AuthManager owns the lifecycle: it wires auth providers, runs flows, persists credentials, and finally hydrates an Integrations container once the user is ready. Happy Path Bootstrap the manager from integrations.auth import AuthManager auth = AuthManager() By default the manager instantiates the first-party auth providers and an in-memory credential store. Pass provider configs or a custom store when you need something different. Run the provider flow (optional when you already have tokens) flow = auth.github.oauth2 step = await flow.authorize(state=\"run-123\") # redirect user to step[\"authorization_url\"] token = await flow.exchange(code=\"oauth-code\", subject=\"user-123\") await auth.store_credentials(\"github\", \"user-123\", token) Flows produce provider-specific UserCredentials models. Persist them with store_credentials so future sessions can load them automatically. Build a session and use integrations async with auth.session(subject=\"user-123\") as integrations: issue = await integrations.github.find_or_create_issue( owner=\"octocat\", repo=\"hello-world\", title=\"Docs shipped\", ) session(...) scopes the work to a subject, loads any stored credentials (unless you disable auto_load_credentials ), runs each provider binding, and returns a ready-to-use Integrations container. When the context manager exits nothing is persisted automatically\u2014call store_credentials when you want to keep new tokens. Need more than the basics? Dive into Flows , the Sessions deep dive , or Credential storage .","title":"Auth Overview"},{"location":"auth/#auth-overview","text":"The auth subsystem keeps provider-specific credential logic out of your application code. AuthManager owns the lifecycle: it wires auth providers, runs flows, persists credentials, and finally hydrates an Integrations container once the user is ready.","title":"Auth Overview"},{"location":"auth/#happy-path","text":"Bootstrap the manager from integrations.auth import AuthManager auth = AuthManager() By default the manager instantiates the first-party auth providers and an in-memory credential store. Pass provider configs or a custom store when you need something different. Run the provider flow (optional when you already have tokens) flow = auth.github.oauth2 step = await flow.authorize(state=\"run-123\") # redirect user to step[\"authorization_url\"] token = await flow.exchange(code=\"oauth-code\", subject=\"user-123\") await auth.store_credentials(\"github\", \"user-123\", token) Flows produce provider-specific UserCredentials models. Persist them with store_credentials so future sessions can load them automatically. Build a session and use integrations async with auth.session(subject=\"user-123\") as integrations: issue = await integrations.github.find_or_create_issue( owner=\"octocat\", repo=\"hello-world\", title=\"Docs shipped\", ) session(...) scopes the work to a subject, loads any stored credentials (unless you disable auto_load_credentials ), runs each provider binding, and returns a ready-to-use Integrations container. When the context manager exits nothing is persisted automatically\u2014call store_credentials when you want to keep new tokens. Need more than the basics? Dive into Flows , the Sessions deep dive , or Credential storage .","title":"Happy Path"},{"location":"auth/flows/","text":"Flows Flows encapsulate the steps required to turn user interactions into credentials. Every auth provider exposes its flows as lazily-instantiated descriptors so you only pay for what you actually run. Flow Basics All flows subclass BaseAuthFlow ( authorize , exchange , refresh ). Providers attach flows with the flow descriptor: from integrations.auth import AuthProvider, flow class MyAuthProvider(AuthProvider): custom = flow(lambda provider: MyCustomFlow(provider.app_credentials)) When you access auth.my_provider.custom the descriptor calls your factory, caches the instance, and always returns the same flow for that provider. OAuth2Flow OAuth2Flow is the default option and powers the built-in GitHub implementation. It wraps Authlib\u2019s AsyncOAuth2Client while enforcing a consistent data model: authorize returns a dict containing the authorization URL and resolved state. exchange swaps the callback data for an OAuth2Token subclass and automatically includes the client ID if required. refresh expects a refresh_token (or one embedded in stored credentials) and returns a new token model. client / create_client give direct access to an AsyncOAuth2Client with scopes, redirect URI, and token wiring set up from OAuth2AppCredentials . Override token_class if your provider extends the default token payload or needs additional parsing. App Credentials Flows receive immutable app credentials ( AppCredentials subclasses) when they are constructed. Use these models to describe required URLs, client IDs, or extra Authlib options. The OAuth2 helpers provide OAuth2AppCredentials , and the GitHub package shows how to fine-tune defaults and environment variable aliases. Building Custom Flows When OAuth2 is not enough, subclass BaseAuthFlow and register the new flow with flow(...) . Your flow gets the provider instance, which exposes app_credentials and helpers such as credential parsing. Return strongly typed models from exchange so bindings can reason about the payload\u2014hook them up in sessions through custom bindings.","title":"Flows"},{"location":"auth/flows/#flows","text":"Flows encapsulate the steps required to turn user interactions into credentials. Every auth provider exposes its flows as lazily-instantiated descriptors so you only pay for what you actually run.","title":"Flows"},{"location":"auth/flows/#flow-basics","text":"All flows subclass BaseAuthFlow ( authorize , exchange , refresh ). Providers attach flows with the flow descriptor: from integrations.auth import AuthProvider, flow class MyAuthProvider(AuthProvider): custom = flow(lambda provider: MyCustomFlow(provider.app_credentials)) When you access auth.my_provider.custom the descriptor calls your factory, caches the instance, and always returns the same flow for that provider.","title":"Flow Basics"},{"location":"auth/flows/#oauth2flow","text":"OAuth2Flow is the default option and powers the built-in GitHub implementation. It wraps Authlib\u2019s AsyncOAuth2Client while enforcing a consistent data model: authorize returns a dict containing the authorization URL and resolved state. exchange swaps the callback data for an OAuth2Token subclass and automatically includes the client ID if required. refresh expects a refresh_token (or one embedded in stored credentials) and returns a new token model. client / create_client give direct access to an AsyncOAuth2Client with scopes, redirect URI, and token wiring set up from OAuth2AppCredentials . Override token_class if your provider extends the default token payload or needs additional parsing.","title":"OAuth2Flow"},{"location":"auth/flows/#app-credentials","text":"Flows receive immutable app credentials ( AppCredentials subclasses) when they are constructed. Use these models to describe required URLs, client IDs, or extra Authlib options. The OAuth2 helpers provide OAuth2AppCredentials , and the GitHub package shows how to fine-tune defaults and environment variable aliases.","title":"App Credentials"},{"location":"auth/flows/#building-custom-flows","text":"When OAuth2 is not enough, subclass BaseAuthFlow and register the new flow with flow(...) . Your flow gets the provider instance, which exposes app_credentials and helpers such as credential parsing. Return strongly typed models from exchange so bindings can reason about the payload\u2014hook them up in sessions through custom bindings.","title":"Building Custom Flows"},{"location":"auth/sessions/","text":"Sessions Deep Dive AuthManager.session(...) is the bridge between stored credentials and the runtime Integrations container. It resolves which auth providers should run, gathers credentials for the active subject, calls bindings, and returns a container primed with provider settings. Anatomy of a Session from integrations.auth.auth_provider_key import AuthProviderKey from integrations.auth import AuthManager auth = AuthManager() async with auth.session( subject=\"user-123\", providers=[AuthProviderKey.GITHUB], with_credentials={AuthProviderKey.GITHUB: {\"access_token\": \"...\"}}, auto_load_credentials=True, overrides={\"github\": {\"timeout\": 30}}, ) as integrations: ... subject identifies the actor. It can be a string or any JSON-serializable mapping. providers (optional) filters which bindings run. When omitted, every registered binding executes. with_credentials lets you bypass the credential store for specific providers. Supply typed UserCredentials or plain mappings and the provider will coerce them. auto_load_credentials (default True ) controls whether the manager looks up stored credentials when with_credentials is missing. Set it to False when handling ephemeral flows. overrides feeds directly into the Integrations constructor. This is ideal for swapping transport configs temporarily without building a new container. Behind the scenes, each auth provider exposes a mapping of bindings keyed by AuthProviderKey . For every binding that matches the filter, the manager: Normalizes the provider key (string, enum, or alias). Parses manual credentials (if provided) into the provider\u2019s UserCredentials model. Loads stored credentials when allowed. Calls binding.to_settings(...) with the manager, subject, and both credential models. Injects the resulting ProviderSettings into the Integrations container. Manual Persistence Sessions intentionally avoid writing to the credential store. They consume whatever you load or inject and then hand you the integrations container. When a flow issues new tokens, call store_credentials yourself before the session ends. Nested Overrides The integrations container also has its own overrides(...) context manager. Combine it with auth sessions to prototype changes quickly: async with auth.session(subject=\"user-123\") as integrations: async with integrations.overrides(github={\"retry_attempts\": 0}): await integrations.github.health_check() Once the overrides exit, the original provider instances are restored but credentials remain available for future sessions.","title":"Sessions"},{"location":"auth/sessions/#sessions-deep-dive","text":"AuthManager.session(...) is the bridge between stored credentials and the runtime Integrations container. It resolves which auth providers should run, gathers credentials for the active subject, calls bindings, and returns a container primed with provider settings.","title":"Sessions Deep Dive"},{"location":"auth/sessions/#anatomy-of-a-session","text":"from integrations.auth.auth_provider_key import AuthProviderKey from integrations.auth import AuthManager auth = AuthManager() async with auth.session( subject=\"user-123\", providers=[AuthProviderKey.GITHUB], with_credentials={AuthProviderKey.GITHUB: {\"access_token\": \"...\"}}, auto_load_credentials=True, overrides={\"github\": {\"timeout\": 30}}, ) as integrations: ... subject identifies the actor. It can be a string or any JSON-serializable mapping. providers (optional) filters which bindings run. When omitted, every registered binding executes. with_credentials lets you bypass the credential store for specific providers. Supply typed UserCredentials or plain mappings and the provider will coerce them. auto_load_credentials (default True ) controls whether the manager looks up stored credentials when with_credentials is missing. Set it to False when handling ephemeral flows. overrides feeds directly into the Integrations constructor. This is ideal for swapping transport configs temporarily without building a new container. Behind the scenes, each auth provider exposes a mapping of bindings keyed by AuthProviderKey . For every binding that matches the filter, the manager: Normalizes the provider key (string, enum, or alias). Parses manual credentials (if provided) into the provider\u2019s UserCredentials model. Loads stored credentials when allowed. Calls binding.to_settings(...) with the manager, subject, and both credential models. Injects the resulting ProviderSettings into the Integrations container.","title":"Anatomy of a Session"},{"location":"auth/sessions/#manual-persistence","text":"Sessions intentionally avoid writing to the credential store. They consume whatever you load or inject and then hand you the integrations container. When a flow issues new tokens, call store_credentials yourself before the session ends.","title":"Manual Persistence"},{"location":"auth/sessions/#nested-overrides","text":"The integrations container also has its own overrides(...) context manager. Combine it with auth sessions to prototype changes quickly: async with auth.session(subject=\"user-123\") as integrations: async with integrations.overrides(github={\"retry_attempts\": 0}): await integrations.github.health_check() Once the overrides exit, the original provider instances are restored but credentials remain available for future sessions.","title":"Nested Overrides"},{"location":"auth/storage/","text":"Credential Storage Auth providers rely on a CredentialStore to keep user tokens around between flow runs. The default InMemoryCredentialStore is great for local development, while production environments should implement the same async contract against a real database or secrets manager. CredentialStore Protocol from integrations.auth.storage import CredentialStore, SubjectLike, StoredData class MyStore(CredentialStore): async def get(self, provider: str, subject: SubjectLike) -> StoredData | None: ... async def set(self, provider: str, subject: SubjectLike, data: StoredData) -> None: ... async def delete(self, provider: str, subject: SubjectLike) -> None: ... provider is the normalized auth provider name (e.g. \"github\" ). subject is either a string or JSON-serializable mapping that scopes credentials to a user, team, or service account. StoredData is a mapping of primitive values. The manager will coerce it back into the provider\u2019s UserCredentials model before bindings run. Implementations should be thread- and async-safe; the store may be accessed concurrently from multiple sessions. In-Memory Reference InMemoryCredentialStore demonstrates the expected behavior: Uses an asyncio.Lock to serialize access. Deep-copies data in and out so callers cannot mutate internal state. Normalizes mapping subjects via json.dumps(..., sort_keys=True) to keep keys stable. Swap it out by passing credential_store=MyStore() to AuthManager(...) . Persistence Tips Persist the provider name and subject alongside the credential payload so revocation becomes easy. Consider storing additional metadata (issued at, expires at) next to the raw token for auditing, but keep it outside the credential payload you return to the manager. Remember to call delete_credentials when the user disconnects, otherwise future sessions will keep using the stale token.","title":"Credential Storage"},{"location":"auth/storage/#credential-storage","text":"Auth providers rely on a CredentialStore to keep user tokens around between flow runs. The default InMemoryCredentialStore is great for local development, while production environments should implement the same async contract against a real database or secrets manager.","title":"Credential Storage"},{"location":"auth/storage/#credentialstore-protocol","text":"from integrations.auth.storage import CredentialStore, SubjectLike, StoredData class MyStore(CredentialStore): async def get(self, provider: str, subject: SubjectLike) -> StoredData | None: ... async def set(self, provider: str, subject: SubjectLike, data: StoredData) -> None: ... async def delete(self, provider: str, subject: SubjectLike) -> None: ... provider is the normalized auth provider name (e.g. \"github\" ). subject is either a string or JSON-serializable mapping that scopes credentials to a user, team, or service account. StoredData is a mapping of primitive values. The manager will coerce it back into the provider\u2019s UserCredentials model before bindings run. Implementations should be thread- and async-safe; the store may be accessed concurrently from multiple sessions.","title":"CredentialStore Protocol"},{"location":"auth/storage/#in-memory-reference","text":"InMemoryCredentialStore demonstrates the expected behavior: Uses an asyncio.Lock to serialize access. Deep-copies data in and out so callers cannot mutate internal state. Normalizes mapping subjects via json.dumps(..., sort_keys=True) to keep keys stable. Swap it out by passing credential_store=MyStore() to AuthManager(...) .","title":"In-Memory Reference"},{"location":"auth/storage/#persistence-tips","text":"Persist the provider name and subject alongside the credential payload so revocation becomes easy. Consider storing additional metadata (issued at, expires at) next to the raw token for auditing, but keep it outside the credential payload you return to the manager. Remember to call delete_credentials when the user disconnects, otherwise future sessions will keep using the stale token.","title":"Persistence Tips"},{"location":"auth-providers/asana_auth/","text":"Asana Auth AsanaAuthProvider exchanges OAuth tokens or personal access tokens for the Asana provider . App Credentials Field Default Env keys Notes authorization_url https://app.asana.com/-/oauth_authorize ASANA_AUTHORIZATION_URL , ASANA_AUTHORIZE_URL Override when using a self-hosted OAuth screen. token_url https://app.asana.com/-/oauth_token ASANA_TOKEN_URL , ASANA_ACCESS_TOKEN_URL Exchange endpoint for OAuth2. client_id None ASANA_CLIENT_ID OAuth client ID. client_secret None ASANA_CLIENT_SECRET OAuth client secret. redirect_uri None ASANA_REDIRECT_URI Optional redirect override. token None ASANA_ACCESS_TOKEN , ASANA_PERSONAL_ACCESS_TOKEN , ASANA_TOKEN Personal access token fallback when skipping OAuth. default_scope None \u2014 Comma/space separated scopes or a sequence. workspace_gid None ASANA_WORKSPACE_GID , ASANA_WORKSPACE Default workspace to inject into settings. User Credentials Tokens are stored as AsanaUserCredentials : Field Type Default access_token str \u2014 token_type str \"Bearer\" refresh_token str or None None scope tuple[str, ...] or None None expires_in int or None None expires_at float or None None id_token str or None None raw dict[str, Any] {} workspace_gid str or None None Persist them with AuthManager.store_credentials or pass them via with_credentials . OAuth Flow from integrations.auth import AuthManager auth = AuthManager(asana={\"client_id\": \"...\", \"client_secret\": \"...\"}) flow = auth.asana.oauth2 # Step 1: send the user through Asana's consent screen step = await flow.authorize(state=\"example-state\") # Step 2: exchange the code for a token token = await flow.exchange(code=\"authorization-code\", subject=\"user-123\") await auth.store_credentials(\"asana\", \"user-123\", token) # Step 3: build a session with hydrated Asana settings async with auth.session(subject=\"user-123\") as integrations: await integrations.asana.get_user(\"me\") The binding prefers stored OAuth tokens but will fall back to the app-level personal access token when present.","title":"Asana Auth"},{"location":"auth-providers/asana_auth/#asana-auth","text":"AsanaAuthProvider exchanges OAuth tokens or personal access tokens for the Asana provider .","title":"Asana Auth"},{"location":"auth-providers/asana_auth/#app-credentials","text":"Field Default Env keys Notes authorization_url https://app.asana.com/-/oauth_authorize ASANA_AUTHORIZATION_URL , ASANA_AUTHORIZE_URL Override when using a self-hosted OAuth screen. token_url https://app.asana.com/-/oauth_token ASANA_TOKEN_URL , ASANA_ACCESS_TOKEN_URL Exchange endpoint for OAuth2. client_id None ASANA_CLIENT_ID OAuth client ID. client_secret None ASANA_CLIENT_SECRET OAuth client secret. redirect_uri None ASANA_REDIRECT_URI Optional redirect override. token None ASANA_ACCESS_TOKEN , ASANA_PERSONAL_ACCESS_TOKEN , ASANA_TOKEN Personal access token fallback when skipping OAuth. default_scope None \u2014 Comma/space separated scopes or a sequence. workspace_gid None ASANA_WORKSPACE_GID , ASANA_WORKSPACE Default workspace to inject into settings.","title":"App Credentials"},{"location":"auth-providers/asana_auth/#user-credentials","text":"Tokens are stored as AsanaUserCredentials : Field Type Default access_token str \u2014 token_type str \"Bearer\" refresh_token str or None None scope tuple[str, ...] or None None expires_in int or None None expires_at float or None None id_token str or None None raw dict[str, Any] {} workspace_gid str or None None Persist them with AuthManager.store_credentials or pass them via with_credentials .","title":"User Credentials"},{"location":"auth-providers/asana_auth/#oauth-flow","text":"from integrations.auth import AuthManager auth = AuthManager(asana={\"client_id\": \"...\", \"client_secret\": \"...\"}) flow = auth.asana.oauth2 # Step 1: send the user through Asana's consent screen step = await flow.authorize(state=\"example-state\") # Step 2: exchange the code for a token token = await flow.exchange(code=\"authorization-code\", subject=\"user-123\") await auth.store_credentials(\"asana\", \"user-123\", token) # Step 3: build a session with hydrated Asana settings async with auth.session(subject=\"user-123\") as integrations: await integrations.asana.get_user(\"me\") The binding prefers stored OAuth tokens but will fall back to the app-level personal access token when present.","title":"OAuth Flow"},{"location":"auth-providers/github_auth/","text":"GitHub Auth GithubAuthProvider wires OAuth or personal access tokens into the GitHub provider . App Credentials Field Default Env keys Notes authorization_url https://github.com/login/oauth/authorize GITHUB_AUTHORIZATION_URL , GITHUB_AUTHORIZE_URL Override when hosting your own OAuth app UI. token_url https://github.com/login/oauth/access_token GITHUB_TOKEN_URL Rarely changed. client_id None GITHUB_CLIENT_ID OAuth app client ID. client_secret None GITHUB_CLIENT_SECRET OAuth app client secret. redirect_uri None GITHUB_REDIRECT_URI Optional override per environment. token None GITHUB_TOKEN , GITHUB_API_TOKEN Drop in a PAT when you skip OAuth. Supply these via keyword args when constructing AuthManager or rely on environment variables. User Credentials Tokens are stored as GithubUserCredentials : Field Type Default access_token str or None None token_type str or None \"Bearer\" refresh_token str or None None scope tuple[str, ...] or None None expires_in int or None None expires_at float or None None id_token str or None None raw dict[str, Any] {} Persist them through AuthManager.store_credentials or plug them into with_credentials . OAuth Flow from integrations.auth import AuthManager auth = AuthManager( github={\"client_id\": \"...\", \"client_secret\": \"...\", \"redirect_uri\": \"...\"}, ) flow = auth.github.oauth2 # Step 1: send user to GitHub step = await flow.authorize(state=\"optional-state\") # Step 2: exchange code after redirect token = await flow.exchange(code=\"authorization-code\", subject=\"user-123\") await auth.store_credentials(\"github\", \"user-123\", token) # Step 3: build a session async with auth.session(subject=\"user-123\") as integrations: await integrations.github.get_authenticated_user() Bindings automatically convert the stored token into GithubSettings , so Integrations.github gains the right authorization headers without additional wiring.","title":"GitHub Auth"},{"location":"auth-providers/github_auth/#github-auth","text":"GithubAuthProvider wires OAuth or personal access tokens into the GitHub provider .","title":"GitHub Auth"},{"location":"auth-providers/github_auth/#app-credentials","text":"Field Default Env keys Notes authorization_url https://github.com/login/oauth/authorize GITHUB_AUTHORIZATION_URL , GITHUB_AUTHORIZE_URL Override when hosting your own OAuth app UI. token_url https://github.com/login/oauth/access_token GITHUB_TOKEN_URL Rarely changed. client_id None GITHUB_CLIENT_ID OAuth app client ID. client_secret None GITHUB_CLIENT_SECRET OAuth app client secret. redirect_uri None GITHUB_REDIRECT_URI Optional override per environment. token None GITHUB_TOKEN , GITHUB_API_TOKEN Drop in a PAT when you skip OAuth. Supply these via keyword args when constructing AuthManager or rely on environment variables.","title":"App Credentials"},{"location":"auth-providers/github_auth/#user-credentials","text":"Tokens are stored as GithubUserCredentials : Field Type Default access_token str or None None token_type str or None \"Bearer\" refresh_token str or None None scope tuple[str, ...] or None None expires_in int or None None expires_at float or None None id_token str or None None raw dict[str, Any] {} Persist them through AuthManager.store_credentials or plug them into with_credentials .","title":"User Credentials"},{"location":"auth-providers/github_auth/#oauth-flow","text":"from integrations.auth import AuthManager auth = AuthManager( github={\"client_id\": \"...\", \"client_secret\": \"...\", \"redirect_uri\": \"...\"}, ) flow = auth.github.oauth2 # Step 1: send user to GitHub step = await flow.authorize(state=\"optional-state\") # Step 2: exchange code after redirect token = await flow.exchange(code=\"authorization-code\", subject=\"user-123\") await auth.store_credentials(\"github\", \"user-123\", token) # Step 3: build a session async with auth.session(subject=\"user-123\") as integrations: await integrations.github.get_authenticated_user() Bindings automatically convert the stored token into GithubSettings , so Integrations.github gains the right authorization headers without additional wiring.","title":"OAuth Flow"},{"location":"auth-providers/google_auth/","text":"Google Auth GoogleAuthProvider centralizes OAuth for Gmail, Google Calendar, Google Docs, Google Drive, and Google Sheets. One set of app credentials can hydrate every Google Workspace provider. App Credentials Field Default Env keys Notes authorization_url https://accounts.google.com/o/oauth2/v2/auth GOOGLE_AUTHORIZATION_URL , GOOGLE_AUTHORIZE_URL Authorization endpoint for Google OAuth. token_url https://oauth2.googleapis.com/token GOOGLE_TOKEN_URL , GOOGLE_ACCESS_TOKEN_URL Token exchange endpoint. client_id None GOOGLE_CLIENT_ID , GOOGLE_OAUTH_CLIENT_ID OAuth client ID. client_secret None GOOGLE_CLIENT_SECRET , GOOGLE_OAUTH_CLIENT_SECRET OAuth client secret. redirect_uri None GOOGLE_REDIRECT_URI , GOOGLE_OAUTH_REDIRECT_URI Optional redirect override. token None GOOGLE_TOKEN , GOOGLE_ACCESS_TOKEN Service account or manually issued access token fallback. refresh_token None GOOGLE_REFRESH_TOKEN , GOOGLE_OAUTH_REFRESH_TOKEN Optional refresh token when bootstrapping from a service account. default_scope None \u2014 Provide scopes for the OAuth flow (string or sequence). Extra keys defined on the credentials (for example default_spreadsheet_id , default_drive_id , or provider-specific base URLs) are forwarded to the corresponding provider settings. User Credentials Tokens are stored as GoogleUserCredentials : Field Type Default access_token str \u2014 token_type str \"Bearer\" refresh_token str or None None scope tuple[str, ...] or None None expires_in int or None None expires_at float or None None id_token str or None None raw dict[str, Any] {} Persist them through AuthManager.store_credentials or supply them via with_credentials when opening a session. OAuth Flow from integrations.auth import AuthManager auth = AuthManager( google={ \"client_id\": \"...\", \"client_secret\": \"...\", \"redirect_uri\": \"https://example.com/oauth2/callback\", \"default_scope\": [ \"https://www.googleapis.com/auth/gmail.readonly\", \"https://www.googleapis.com/auth/calendar.events\", ], } ) flow = auth.google.oauth2 # Step 1: redirect the user through Google's consent screen step = await flow.authorize(state=\"subject-123\") # Step 2: exchange the authorization code token = await flow.exchange(code=\"auth-code\", subject=\"user-123\") await auth.store_credentials(\"google\", \"user-123\", token) # Step 3: build a session and use any Google provider async with auth.session(subject=\"user-123\") as integrations: await integrations.gmail.get_profile() await integrations.google_calendar.list_events() Bindings fan out to each Google provider, so one stored token unlocks Gmail, Calendar, Docs, Drive, and Sheets simultaneously.","title":"Google Auth"},{"location":"auth-providers/google_auth/#google-auth","text":"GoogleAuthProvider centralizes OAuth for Gmail, Google Calendar, Google Docs, Google Drive, and Google Sheets. One set of app credentials can hydrate every Google Workspace provider.","title":"Google Auth"},{"location":"auth-providers/google_auth/#app-credentials","text":"Field Default Env keys Notes authorization_url https://accounts.google.com/o/oauth2/v2/auth GOOGLE_AUTHORIZATION_URL , GOOGLE_AUTHORIZE_URL Authorization endpoint for Google OAuth. token_url https://oauth2.googleapis.com/token GOOGLE_TOKEN_URL , GOOGLE_ACCESS_TOKEN_URL Token exchange endpoint. client_id None GOOGLE_CLIENT_ID , GOOGLE_OAUTH_CLIENT_ID OAuth client ID. client_secret None GOOGLE_CLIENT_SECRET , GOOGLE_OAUTH_CLIENT_SECRET OAuth client secret. redirect_uri None GOOGLE_REDIRECT_URI , GOOGLE_OAUTH_REDIRECT_URI Optional redirect override. token None GOOGLE_TOKEN , GOOGLE_ACCESS_TOKEN Service account or manually issued access token fallback. refresh_token None GOOGLE_REFRESH_TOKEN , GOOGLE_OAUTH_REFRESH_TOKEN Optional refresh token when bootstrapping from a service account. default_scope None \u2014 Provide scopes for the OAuth flow (string or sequence). Extra keys defined on the credentials (for example default_spreadsheet_id , default_drive_id , or provider-specific base URLs) are forwarded to the corresponding provider settings.","title":"App Credentials"},{"location":"auth-providers/google_auth/#user-credentials","text":"Tokens are stored as GoogleUserCredentials : Field Type Default access_token str \u2014 token_type str \"Bearer\" refresh_token str or None None scope tuple[str, ...] or None None expires_in int or None None expires_at float or None None id_token str or None None raw dict[str, Any] {} Persist them through AuthManager.store_credentials or supply them via with_credentials when opening a session.","title":"User Credentials"},{"location":"auth-providers/google_auth/#oauth-flow","text":"from integrations.auth import AuthManager auth = AuthManager( google={ \"client_id\": \"...\", \"client_secret\": \"...\", \"redirect_uri\": \"https://example.com/oauth2/callback\", \"default_scope\": [ \"https://www.googleapis.com/auth/gmail.readonly\", \"https://www.googleapis.com/auth/calendar.events\", ], } ) flow = auth.google.oauth2 # Step 1: redirect the user through Google's consent screen step = await flow.authorize(state=\"subject-123\") # Step 2: exchange the authorization code token = await flow.exchange(code=\"auth-code\", subject=\"user-123\") await auth.store_credentials(\"google\", \"user-123\", token) # Step 3: build a session and use any Google provider async with auth.session(subject=\"user-123\") as integrations: await integrations.gmail.get_profile() await integrations.google_calendar.list_events() Bindings fan out to each Google provider, so one stored token unlocks Gmail, Calendar, Docs, Drive, and Sheets simultaneously.","title":"OAuth Flow"},{"location":"auth-providers/hubspot_auth/","text":"HubSpot Auth HubspotAuthProvider supports OAuth2 and private app tokens for the HubSpot provider . App Credentials Field Default Env keys Notes authorization_url https://app.hubspot.com/oauth/authorize HUBSPOT_AUTHORIZATION_URL , HUBSPOT_AUTHORIZE_URL OAuth authorization endpoint. token_url https://api.hubapi.com/oauth/v1/token HUBSPOT_TOKEN_URL , HUBSPOT_ACCESS_TOKEN_URL Token exchange endpoint. client_id None HUBSPOT_CLIENT_ID OAuth client ID. client_secret None HUBSPOT_CLIENT_SECRET OAuth client secret. redirect_uri None HUBSPOT_REDIRECT_URI Optional redirect override. token None HUBSPOT_ACCESS_TOKEN , HUBSPOT_TOKEN , HUBSPOT_PRIVATE_APP_TOKEN Private app token fallback. default_scope None \u2014 Provide scopes for OAuth if you need more than the defaults. User Credentials Tokens are stored as HubspotUserCredentials : Field Type Default access_token str \u2014 token_type str \"Bearer\" refresh_token str or None None scope tuple[str, ...] or None None expires_in int or None None expires_at float or None None id_token str or None None raw dict[str, Any] {} Persist them via the auth manager just like other providers. OAuth Flow from integrations.auth import AuthManager auth = AuthManager(hubspot={\"client_id\": \"...\", \"client_secret\": \"...\"}) flow = auth.hubspot.oauth2 # Step 1: direct the user to HubSpot step = await flow.authorize(state=\"deal-sync\") # Step 2: exchange the code and store the token token = await flow.exchange(code=\"code\", subject=\"team-123\") await auth.store_credentials(\"hubspot\", \"team-123\", token) # Step 3: request data async with auth.session(subject=\"team-123\") as integrations: await integrations.hubspot.get_contacts() If you prefer private app tokens, skip the flow and configure token on the auth provider. The binding will fall back to that value when no user token is stored.","title":"HubSpot Auth"},{"location":"auth-providers/hubspot_auth/#hubspot-auth","text":"HubspotAuthProvider supports OAuth2 and private app tokens for the HubSpot provider .","title":"HubSpot Auth"},{"location":"auth-providers/hubspot_auth/#app-credentials","text":"Field Default Env keys Notes authorization_url https://app.hubspot.com/oauth/authorize HUBSPOT_AUTHORIZATION_URL , HUBSPOT_AUTHORIZE_URL OAuth authorization endpoint. token_url https://api.hubapi.com/oauth/v1/token HUBSPOT_TOKEN_URL , HUBSPOT_ACCESS_TOKEN_URL Token exchange endpoint. client_id None HUBSPOT_CLIENT_ID OAuth client ID. client_secret None HUBSPOT_CLIENT_SECRET OAuth client secret. redirect_uri None HUBSPOT_REDIRECT_URI Optional redirect override. token None HUBSPOT_ACCESS_TOKEN , HUBSPOT_TOKEN , HUBSPOT_PRIVATE_APP_TOKEN Private app token fallback. default_scope None \u2014 Provide scopes for OAuth if you need more than the defaults.","title":"App Credentials"},{"location":"auth-providers/hubspot_auth/#user-credentials","text":"Tokens are stored as HubspotUserCredentials : Field Type Default access_token str \u2014 token_type str \"Bearer\" refresh_token str or None None scope tuple[str, ...] or None None expires_in int or None None expires_at float or None None id_token str or None None raw dict[str, Any] {} Persist them via the auth manager just like other providers.","title":"User Credentials"},{"location":"auth-providers/hubspot_auth/#oauth-flow","text":"from integrations.auth import AuthManager auth = AuthManager(hubspot={\"client_id\": \"...\", \"client_secret\": \"...\"}) flow = auth.hubspot.oauth2 # Step 1: direct the user to HubSpot step = await flow.authorize(state=\"deal-sync\") # Step 2: exchange the code and store the token token = await flow.exchange(code=\"code\", subject=\"team-123\") await auth.store_credentials(\"hubspot\", \"team-123\", token) # Step 3: request data async with auth.session(subject=\"team-123\") as integrations: await integrations.hubspot.get_contacts() If you prefer private app tokens, skip the flow and configure token on the auth provider. The binding will fall back to that value when no user token is stored.","title":"OAuth Flow"},{"location":"auth-providers/notion_auth/","text":"Notion Auth NotionAuthProvider wires OAuth tokens or integration tokens into the Notion provider . App Credentials Field Default Env keys Notes authorization_url https://api.notion.com/v1/oauth/authorize NOTION_AUTHORIZATION_URL , NOTION_AUTHORIZE_URL OAuth authorization endpoint. token_url https://api.notion.com/v1/oauth/token NOTION_TOKEN_URL , NOTION_ACCESS_TOKEN_URL Token exchange endpoint. client_id None NOTION_CLIENT_ID OAuth client ID. client_secret None NOTION_CLIENT_SECRET OAuth client secret. redirect_uri None NOTION_REDIRECT_URI Optional redirect override. token None NOTION_TOKEN , NOTION_INTEGRATION_TOKEN Internal integration token fallback. default_scope None \u2014 Provide scopes when using public OAuth. version None NOTION_VERSION , NOTION_API_VERSION Override API version header for all bindings. User Credentials Tokens are stored as NotionUserCredentials : Field Type Default access_token str \u2014 token_type str \"Bearer\" refresh_token str or None None scope tuple[str, ...] or None None expires_in int or None None expires_at float or None None id_token str or None None raw dict[str, Any] {} workspace_id str or None None workspace_name str or None None workspace_icon str or None None Persist them with AuthManager.store_credentials or supply them via with_credentials . OAuth Flow from integrations.auth import AuthManager auth = AuthManager(notion={\"client_id\": \"...\", \"client_secret\": \"...\"}) flow = auth.notion.oauth2 # Step 1: send the user to Notion's consent screen step = await flow.authorize(state=\"docs-sync\") # Step 2: exchange the authorization code token = await flow.exchange(code=\"code\", subject=\"workspace-123\") await auth.store_credentials(\"notion\", \"workspace-123\", token) # Step 3: use Notion through the integrations container async with auth.session(subject=\"workspace-123\") as integrations: await integrations.notion.list_databases() When you already have an internal integration token, skip the flow and set token on the auth provider. Bindings will automatically inject the correct version header and reuse any overrides you supplied on the app credentials.","title":"Notion Auth"},{"location":"auth-providers/notion_auth/#notion-auth","text":"NotionAuthProvider wires OAuth tokens or integration tokens into the Notion provider .","title":"Notion Auth"},{"location":"auth-providers/notion_auth/#app-credentials","text":"Field Default Env keys Notes authorization_url https://api.notion.com/v1/oauth/authorize NOTION_AUTHORIZATION_URL , NOTION_AUTHORIZE_URL OAuth authorization endpoint. token_url https://api.notion.com/v1/oauth/token NOTION_TOKEN_URL , NOTION_ACCESS_TOKEN_URL Token exchange endpoint. client_id None NOTION_CLIENT_ID OAuth client ID. client_secret None NOTION_CLIENT_SECRET OAuth client secret. redirect_uri None NOTION_REDIRECT_URI Optional redirect override. token None NOTION_TOKEN , NOTION_INTEGRATION_TOKEN Internal integration token fallback. default_scope None \u2014 Provide scopes when using public OAuth. version None NOTION_VERSION , NOTION_API_VERSION Override API version header for all bindings.","title":"App Credentials"},{"location":"auth-providers/notion_auth/#user-credentials","text":"Tokens are stored as NotionUserCredentials : Field Type Default access_token str \u2014 token_type str \"Bearer\" refresh_token str or None None scope tuple[str, ...] or None None expires_in int or None None expires_at float or None None id_token str or None None raw dict[str, Any] {} workspace_id str or None None workspace_name str or None None workspace_icon str or None None Persist them with AuthManager.store_credentials or supply them via with_credentials .","title":"User Credentials"},{"location":"auth-providers/notion_auth/#oauth-flow","text":"from integrations.auth import AuthManager auth = AuthManager(notion={\"client_id\": \"...\", \"client_secret\": \"...\"}) flow = auth.notion.oauth2 # Step 1: send the user to Notion's consent screen step = await flow.authorize(state=\"docs-sync\") # Step 2: exchange the authorization code token = await flow.exchange(code=\"code\", subject=\"workspace-123\") await auth.store_credentials(\"notion\", \"workspace-123\", token) # Step 3: use Notion through the integrations container async with auth.session(subject=\"workspace-123\") as integrations: await integrations.notion.list_databases() When you already have an internal integration token, skip the flow and set token on the auth provider. Bindings will automatically inject the correct version header and reuse any overrides you supplied on the app credentials.","title":"OAuth Flow"},{"location":"auth-providers/slack_auth/","text":"Slack Auth SlackAuthProvider manages OAuth and bot tokens for the Slack provider . App Credentials Field Default Env keys Notes authorization_url https://slack.com/oauth/v2/authorize SLACK_AUTHORIZATION_URL , SLACK_AUTHORIZE_URL OAuth authorization endpoint. token_url https://slack.com/api/oauth.v2.access SLACK_TOKEN_URL , SLACK_ACCESS_TOKEN_URL OAuth token exchange endpoint. client_id None SLACK_CLIENT_ID OAuth client ID. client_secret None SLACK_CLIENT_SECRET OAuth client secret. redirect_uri None SLACK_REDIRECT_URI Optional redirect override. bot_token None SLACK_BOT_TOKEN , SLACK_TOKEN Bot token fallback when you skip OAuth. user_token None SLACK_USER_TOKEN Alternate fallback used when no bot token is configured. default_scope None \u2014 Provide scopes for the OAuth flow. User Credentials Tokens are stored as SlackUserCredentials : Field Type Default access_token str \u2014 token_type str \"Bearer\" refresh_token str or None None scope tuple[str, ...] or None None expires_in int or None None expires_at float or None None id_token str or None None raw dict[str, Any] {} bot_user_id str or None None team_id str or None None team_name str or None None authed_user_id str or None None Persist them via AuthManager.store_credentials or supply them through with_credentials . OAuth Flow from integrations.auth import AuthManager auth = AuthManager(slack={\"client_id\": \"...\", \"client_secret\": \"...\"}) flow = auth.slack.oauth2 # Step 1: redirect to Slack step = await flow.authorize(state=\"workspace-join\") # Step 2: exchange the code token = await flow.exchange(code=\"code\", subject=\"team-123\") await auth.store_credentials(\"slack\", \"team-123\", token) # Step 3: call Slack APIs async with auth.session(subject=\"team-123\") as integrations: await integrations.slack.conversations_list() If you already have a bot token, skip the flow and configure bot_token (or user_token ). Bindings will automatically propagate any overrides you attach to the app credentials, such as custom base URLs or timeouts.","title":"Slack Auth"},{"location":"auth-providers/slack_auth/#slack-auth","text":"SlackAuthProvider manages OAuth and bot tokens for the Slack provider .","title":"Slack Auth"},{"location":"auth-providers/slack_auth/#app-credentials","text":"Field Default Env keys Notes authorization_url https://slack.com/oauth/v2/authorize SLACK_AUTHORIZATION_URL , SLACK_AUTHORIZE_URL OAuth authorization endpoint. token_url https://slack.com/api/oauth.v2.access SLACK_TOKEN_URL , SLACK_ACCESS_TOKEN_URL OAuth token exchange endpoint. client_id None SLACK_CLIENT_ID OAuth client ID. client_secret None SLACK_CLIENT_SECRET OAuth client secret. redirect_uri None SLACK_REDIRECT_URI Optional redirect override. bot_token None SLACK_BOT_TOKEN , SLACK_TOKEN Bot token fallback when you skip OAuth. user_token None SLACK_USER_TOKEN Alternate fallback used when no bot token is configured. default_scope None \u2014 Provide scopes for the OAuth flow.","title":"App Credentials"},{"location":"auth-providers/slack_auth/#user-credentials","text":"Tokens are stored as SlackUserCredentials : Field Type Default access_token str \u2014 token_type str \"Bearer\" refresh_token str or None None scope tuple[str, ...] or None None expires_in int or None None expires_at float or None None id_token str or None None raw dict[str, Any] {} bot_user_id str or None None team_id str or None None team_name str or None None authed_user_id str or None None Persist them via AuthManager.store_credentials or supply them through with_credentials .","title":"User Credentials"},{"location":"auth-providers/slack_auth/#oauth-flow","text":"from integrations.auth import AuthManager auth = AuthManager(slack={\"client_id\": \"...\", \"client_secret\": \"...\"}) flow = auth.slack.oauth2 # Step 1: redirect to Slack step = await flow.authorize(state=\"workspace-join\") # Step 2: exchange the code token = await flow.exchange(code=\"code\", subject=\"team-123\") await auth.store_credentials(\"slack\", \"team-123\", token) # Step 3: call Slack APIs async with auth.session(subject=\"team-123\") as integrations: await integrations.slack.conversations_list() If you already have a bot token, skip the flow and configure bot_token (or user_token ). Bindings will automatically propagate any overrides you attach to the app credentials, such as custom base URLs or timeouts.","title":"OAuth Flow"},{"location":"core/actions/","text":"Actions Providers expose async callables for common workflows. Built-ins talk to HTTP APIs today, but actions stay transport-agnostic. Call Actions from integrations import Integrations integrations = Integrations() result = await integrations.slack.send_channel_message( channel=\"#ops\", text=\"deploy finished\", ) Use provider.actions if you need discovery at runtime. from integrations import Integrations integrations = Integrations() for name in integrations.github.actions: print(name) Register Actions Actions extend BaseAction and register on providers via the action() descriptor. The descriptor instantiates the action once per provider, injects the provider instance, and optionally derives name/description metadata from the class. Review the Providers guide for how providers are hydrated. from integrations.core import ( BaseAction, BaseProvider, HttpxClientMixin, ProviderSettings, action, ) class ChatSettings(ProviderSettings): api_token: str class PostMessage(BaseAction): async def __call__(self, channel: str, text: str) -> dict: response = await self.provider.request( \"POST\", \"/chat.postMessage\", json={\"channel\": channel, \"text\": text}, ) return self.provider.process_httpx_response(response) class ChatProvider(HttpxClientMixin, BaseProvider[ChatSettings]): post_message: PostMessage post_message = action(PostMessage, description=\"Send a chat message.\") When an action exposes reusable behavior, move that logic into a provider-scoped base action under src/integrations/providers/<provider>/actions/ . Raw Requests Every HTTP provider publishes raw_request for one-off endpoints. from integrations import Integrations integrations = Integrations() payload = await integrations.github.raw_request( \"GET\", \"/repos/octocat/Hello-World\", params={\"per_page\": 10}, ) When a provider opts into the HTTPX mixin, it handles auth headers, base URLs, timeouts, and JSON parsing for you. Agent Tools Actions can become OpenAI function tools with one line. from integrations import Integrations integrations = Integrations() tool = integrations.google_drive.upload_file.as_tool() Install openai-agents to activate this bridge. See the OpenAI Agents guide for wiring these tools into chat completions.","title":"Actions"},{"location":"core/actions/#actions","text":"Providers expose async callables for common workflows. Built-ins talk to HTTP APIs today, but actions stay transport-agnostic.","title":"Actions"},{"location":"core/actions/#call-actions","text":"from integrations import Integrations integrations = Integrations() result = await integrations.slack.send_channel_message( channel=\"#ops\", text=\"deploy finished\", ) Use provider.actions if you need discovery at runtime. from integrations import Integrations integrations = Integrations() for name in integrations.github.actions: print(name)","title":"Call Actions"},{"location":"core/actions/#register-actions","text":"Actions extend BaseAction and register on providers via the action() descriptor. The descriptor instantiates the action once per provider, injects the provider instance, and optionally derives name/description metadata from the class. Review the Providers guide for how providers are hydrated. from integrations.core import ( BaseAction, BaseProvider, HttpxClientMixin, ProviderSettings, action, ) class ChatSettings(ProviderSettings): api_token: str class PostMessage(BaseAction): async def __call__(self, channel: str, text: str) -> dict: response = await self.provider.request( \"POST\", \"/chat.postMessage\", json={\"channel\": channel, \"text\": text}, ) return self.provider.process_httpx_response(response) class ChatProvider(HttpxClientMixin, BaseProvider[ChatSettings]): post_message: PostMessage post_message = action(PostMessage, description=\"Send a chat message.\") When an action exposes reusable behavior, move that logic into a provider-scoped base action under src/integrations/providers/<provider>/actions/ .","title":"Register Actions"},{"location":"core/actions/#raw-requests","text":"Every HTTP provider publishes raw_request for one-off endpoints. from integrations import Integrations integrations = Integrations() payload = await integrations.github.raw_request( \"GET\", \"/repos/octocat/Hello-World\", params={\"per_page\": 10}, ) When a provider opts into the HTTPX mixin, it handles auth headers, base URLs, timeouts, and JSON parsing for you.","title":"Raw Requests"},{"location":"core/actions/#agent-tools","text":"Actions can become OpenAI function tools with one line. from integrations import Integrations integrations = Integrations() tool = integrations.google_drive.upload_file.as_tool() Install openai-agents to activate this bridge. See the OpenAI Agents guide for wiring these tools into chat completions.","title":"Agent Tools"},{"location":"core/integrations-container/","text":"Integrations Container Integrations orchestrates provider instantiation, lazy registration, and environment-aware configuration. Providers appear as attributes on the container ( integrations.slack , integrations.github , etc.) and expose their actions directly. Auto-configuration By default the container attempts to hydrate any registered provider using environment variables and the defaults defined on its ProviderSettings . from integrations import Integrations integrations = Integrations(auto_configure=True) If auto_configure stays True , every provider registered in the global registry is instantiated. Providers whose settings cannot validate (for example, because a required token is missing) are skipped until you supply credentials. Disable auto-configuration when you want explicit control over which providers load: integrations = Integrations(auto_configure=False) integrations.register(\"slack\", {\"token\": \"xoxb-...\"}) You can also pass provider configs to the constructor ( Integrations(slack=...) ) to seed the container up front. Overrides Overrides let you swap a provider (or just a subset of its settings) for the duration of a scope. The override manager is both async- and sync-aware; prefer the async form when you are already inside an event loop. from integrations import Integrations, provider_override integrations = Integrations() async with integrations.overrides( github=provider_override({\"token\": \"ghp-runtime\"}, merge=True), ) as runtime: await runtime.github.create_issue(...) Use merge=True (the default when you omit merge ) to patch into existing settings; pass merge=False to replace the provider entirely. When an override adds a provider that was not previously registered, it is removed after exiting the context. Manual registration and lookup The container stores providers by their canonical key. Use .register() to add or replace an entry at runtime, and .get(...) or dictionary-style access to fetch instances. integrations.register(\"notion\", {\"token\": \"secret_...\"}) notion = integrations[\"notion\"] For details on how providers are implemented and registered, see the Providers guide.","title":"Container"},{"location":"core/integrations-container/#integrations-container","text":"Integrations orchestrates provider instantiation, lazy registration, and environment-aware configuration. Providers appear as attributes on the container ( integrations.slack , integrations.github , etc.) and expose their actions directly.","title":"Integrations Container"},{"location":"core/integrations-container/#auto-configuration","text":"By default the container attempts to hydrate any registered provider using environment variables and the defaults defined on its ProviderSettings . from integrations import Integrations integrations = Integrations(auto_configure=True) If auto_configure stays True , every provider registered in the global registry is instantiated. Providers whose settings cannot validate (for example, because a required token is missing) are skipped until you supply credentials. Disable auto-configuration when you want explicit control over which providers load: integrations = Integrations(auto_configure=False) integrations.register(\"slack\", {\"token\": \"xoxb-...\"}) You can also pass provider configs to the constructor ( Integrations(slack=...) ) to seed the container up front.","title":"Auto-configuration"},{"location":"core/integrations-container/#overrides","text":"Overrides let you swap a provider (or just a subset of its settings) for the duration of a scope. The override manager is both async- and sync-aware; prefer the async form when you are already inside an event loop. from integrations import Integrations, provider_override integrations = Integrations() async with integrations.overrides( github=provider_override({\"token\": \"ghp-runtime\"}, merge=True), ) as runtime: await runtime.github.create_issue(...) Use merge=True (the default when you omit merge ) to patch into existing settings; pass merge=False to replace the provider entirely. When an override adds a provider that was not previously registered, it is removed after exiting the context.","title":"Overrides"},{"location":"core/integrations-container/#manual-registration-and-lookup","text":"The container stores providers by their canonical key. Use .register() to add or replace an entry at runtime, and .get(...) or dictionary-style access to fetch instances. integrations.register(\"notion\", {\"token\": \"secret_...\"}) notion = integrations[\"notion\"] For details on how providers are implemented and registered, see the Providers guide.","title":"Manual registration and lookup"},{"location":"core/providers/","text":"Providers Providers are runtime adapters that expose a given service's API through typed actions. They combine a Pydantic settings model, transport helpers, and an action surface that the Integrations container wires together\u2014you interact with providers through integrations.<provider> . Settings and environment loading Every provider ships a ProviderSettings subclass that drives validation and environment-driven configuration. from integrations.providers.slack import SlackSettings settings = SlackSettings() # pulls from SLACK_* env vars by default settings.token # -> resolves aliases like SLACK_BOT_TOKEN ProviderSettings extends pydantic_settings.BaseSettings , so aliases declared with Field(validation_alias=...) or AliasChoices automatically map environment variables into structured data. Providers keep these models small and explicit\u2014when the container hydrates a provider it passes these settings along, whether they come from environment variables, overrides, or explicit configuration. Container hydration The container instantiates providers on demand. Pass configuration as keyword arguments to Integrations(...) , or rely on environment values when auto_configure=True . from integrations import Integrations integrations = Integrations(slack={\"token\": \"xoxb-...\"}) await integrations.slack.send_channel_message(channel=\"#team\", text=\"Hello\") Providers that need HTTP helpers stack HttpxClientMixin on the base class. The mixin exposes request(...) , httpx_client() , and response-processing hooks so actions can stay focused on the payload rather than client setup. See Actions for registering and extending action surfaces. Registering providers Providers register themselves on import by calling register_provider(...) inside their package __init__ . The registry maps a ProviderKey (or string alias) to the provider class. Once registered, the Integrations container can hydrate the provider automatically. from integrations.core import ( BaseProvider, ProviderKey, ProviderSettings, RawHttpRequestAction, action, register_provider, ) class DemoSettings(ProviderSettings): api_key: str class DemoProvider(BaseProvider[DemoSettings]): settings_class = DemoSettings raw_request = action(RawHttpRequestAction) register_provider(ProviderKey(\"demo\"), DemoProvider) Third-party packages can follow the same pattern\u2014importing them is enough for available_providers() and the container to see the new entry. Once the module that registers the provider is imported, the container can hydrate it like any other first-party integration: from integrations import Integrations import demo_provider_package # ensures register_provider(...) runs integrations = Integrations(demo={\"api_key\": \"demo-123\"}) await integrations.demo.raw_request( method=\"GET\", url=\"/v1/resources\", ) Building a first-party provider First-party providers live under src/integrations/providers/<provider>/ and follow a consistent structure: <provider>_settings.py : define the ProviderSettings subclass and map env aliases via SettingsConfigDict . <provider>_provider.py : extend BaseProvider , declare typed action attributes, and assign descriptors via action(...) . actions/ : house one action per file so dependencies stay scoped. __init__.py : register the provider by importing register_provider and the provider class, then calling register_provider(ProviderKey.<PROVIDER>, ...) . With that in place, the provider becomes available through the container and can participate in overrides, auto-configuration, and introspection. See the Integrations container documentation for container-specific behavior.","title":"Providers"},{"location":"core/providers/#providers","text":"Providers are runtime adapters that expose a given service's API through typed actions. They combine a Pydantic settings model, transport helpers, and an action surface that the Integrations container wires together\u2014you interact with providers through integrations.<provider> .","title":"Providers"},{"location":"core/providers/#settings-and-environment-loading","text":"Every provider ships a ProviderSettings subclass that drives validation and environment-driven configuration. from integrations.providers.slack import SlackSettings settings = SlackSettings() # pulls from SLACK_* env vars by default settings.token # -> resolves aliases like SLACK_BOT_TOKEN ProviderSettings extends pydantic_settings.BaseSettings , so aliases declared with Field(validation_alias=...) or AliasChoices automatically map environment variables into structured data. Providers keep these models small and explicit\u2014when the container hydrates a provider it passes these settings along, whether they come from environment variables, overrides, or explicit configuration.","title":"Settings and environment loading"},{"location":"core/providers/#container-hydration","text":"The container instantiates providers on demand. Pass configuration as keyword arguments to Integrations(...) , or rely on environment values when auto_configure=True . from integrations import Integrations integrations = Integrations(slack={\"token\": \"xoxb-...\"}) await integrations.slack.send_channel_message(channel=\"#team\", text=\"Hello\") Providers that need HTTP helpers stack HttpxClientMixin on the base class. The mixin exposes request(...) , httpx_client() , and response-processing hooks so actions can stay focused on the payload rather than client setup. See Actions for registering and extending action surfaces.","title":"Container hydration"},{"location":"core/providers/#registering-providers","text":"Providers register themselves on import by calling register_provider(...) inside their package __init__ . The registry maps a ProviderKey (or string alias) to the provider class. Once registered, the Integrations container can hydrate the provider automatically. from integrations.core import ( BaseProvider, ProviderKey, ProviderSettings, RawHttpRequestAction, action, register_provider, ) class DemoSettings(ProviderSettings): api_key: str class DemoProvider(BaseProvider[DemoSettings]): settings_class = DemoSettings raw_request = action(RawHttpRequestAction) register_provider(ProviderKey(\"demo\"), DemoProvider) Third-party packages can follow the same pattern\u2014importing them is enough for available_providers() and the container to see the new entry. Once the module that registers the provider is imported, the container can hydrate it like any other first-party integration: from integrations import Integrations import demo_provider_package # ensures register_provider(...) runs integrations = Integrations(demo={\"api_key\": \"demo-123\"}) await integrations.demo.raw_request( method=\"GET\", url=\"/v1/resources\", )","title":"Registering providers"},{"location":"core/providers/#building-a-first-party-provider","text":"First-party providers live under src/integrations/providers/<provider>/ and follow a consistent structure: <provider>_settings.py : define the ProviderSettings subclass and map env aliases via SettingsConfigDict . <provider>_provider.py : extend BaseProvider , declare typed action attributes, and assign descriptors via action(...) . actions/ : house one action per file so dependencies stay scoped. __init__.py : register the provider by importing register_provider and the provider class, then calling register_provider(ProviderKey.<PROVIDER>, ...) . With that in place, the provider becomes available through the container and can participate in overrides, auto-configuration, and introspection. See the Integrations container documentation for container-specific behavior.","title":"Building a first-party provider"},{"location":"extras/openai-agents/","text":"OpenAI Agents Integration Convert any action into an OpenAI-compatible tool with as_tool and wire it into the openai-agents SDK. Prerequisites uv add \"integrations[agents] @ git+https://github.com/anishxyz/integrations\" Load your environment (tokens, etc.) before constructing the container. Build Tools from agents import Agent, Runner from integrations import Integrations integrations = Integrations() repo_tool = integrations.github.find_repository.as_tool( name=\"find_github_repo\", description=\"Find a GitHub repository by owner/name.\", ) agent = Agent( name=\"repo assistant\", instructions=\"Answer questions with GitHub data.\", tools=[repo_tool], ) result = await Runner.run(agent, input=\"Find openai/openai-python\") print(result.final_output) as_tool accepts optional overrides ( description , name , docstring_style , etc.) if you want to tweak the surfaced schema. The action remains the source of truth for parameter validation and execution. Configure any required provider settings (for example GITHUB_TOKEN ) before running the agent so the action can reach the upstream API. Custom Providers You can expose your own providers to agents too: from integrations import BaseAction, BaseProvider, Integrations, ProviderSettings, action class WeatherSettings(ProviderSettings): default_conditions: str = \"clear skies\" class GetForecast(BaseAction): async def __call__(self, city: str) -> str: return f\"{city}: {self.provider.settings.default_conditions}\" class WeatherProvider(BaseProvider[WeatherSettings]): settings_class = WeatherSettings forecast = action(GetForecast, description=\"Get today's forecast.\") integrations = Integrations(weather=WeatherProvider()) weather_tool = integrations.weather.forecast.as_tool(name=\"get_weather\") Every action stays async, reusable outside of agents, and can still use provider helpers like HTTP clients when needed.","title":"OpenAI Agents"},{"location":"extras/openai-agents/#openai-agents-integration","text":"Convert any action into an OpenAI-compatible tool with as_tool and wire it into the openai-agents SDK.","title":"OpenAI Agents Integration"},{"location":"extras/openai-agents/#prerequisites","text":"uv add \"integrations[agents] @ git+https://github.com/anishxyz/integrations\" Load your environment (tokens, etc.) before constructing the container.","title":"Prerequisites"},{"location":"extras/openai-agents/#build-tools","text":"from agents import Agent, Runner from integrations import Integrations integrations = Integrations() repo_tool = integrations.github.find_repository.as_tool( name=\"find_github_repo\", description=\"Find a GitHub repository by owner/name.\", ) agent = Agent( name=\"repo assistant\", instructions=\"Answer questions with GitHub data.\", tools=[repo_tool], ) result = await Runner.run(agent, input=\"Find openai/openai-python\") print(result.final_output) as_tool accepts optional overrides ( description , name , docstring_style , etc.) if you want to tweak the surfaced schema. The action remains the source of truth for parameter validation and execution. Configure any required provider settings (for example GITHUB_TOKEN ) before running the agent so the action can reach the upstream API.","title":"Build Tools"},{"location":"extras/openai-agents/#custom-providers","text":"You can expose your own providers to agents too: from integrations import BaseAction, BaseProvider, Integrations, ProviderSettings, action class WeatherSettings(ProviderSettings): default_conditions: str = \"clear skies\" class GetForecast(BaseAction): async def __call__(self, city: str) -> str: return f\"{city}: {self.provider.settings.default_conditions}\" class WeatherProvider(BaseProvider[WeatherSettings]): settings_class = WeatherSettings forecast = action(GetForecast, description=\"Get today's forecast.\") integrations = Integrations(weather=WeatherProvider()) weather_tool = integrations.weather.forecast.as_tool(name=\"get_weather\") Every action stays async, reusable outside of agents, and can still use provider helpers like HTTP clients when needed.","title":"Custom Providers"},{"location":"providers/asana/","text":"Asana Settings Field Default Env keys Notes token None ASANA_ACCESS_TOKEN ASANA_PERSONAL_ACCESS_TOKEN ASANA_TOKEN Required for authenticated requests. workspace_gid None ASANA_WORKSPACE_GID ASANA_WORKSPACE Optional default workspace context. base_url https://app.asana.com/api/1.0 ASANA_BASE_URL Override for self-hosted proxies. timeout 10.0 ASANA_TIMEOUT Seconds. user_agent integrations-sdk ASANA_USER_AGENT Added to every request. Quick Call from integrations import Integrations async def new_task(): integrations = Integrations(asana={\"token\": \"...\", \"workspace_gid\": \"123\"}) task = await integrations.asana.create_task( workspace_gid=\"123\", name=\"Ship docs\", ) return task[\"gid\"] Notable actions: create_task , find_project , raw_request . Responses are auto-unwrapped so .create_task returns the Asana \"data\" payload.","title":"Asana"},{"location":"providers/asana/#asana","text":"","title":"Asana"},{"location":"providers/asana/#settings","text":"Field Default Env keys Notes token None ASANA_ACCESS_TOKEN ASANA_PERSONAL_ACCESS_TOKEN ASANA_TOKEN Required for authenticated requests. workspace_gid None ASANA_WORKSPACE_GID ASANA_WORKSPACE Optional default workspace context. base_url https://app.asana.com/api/1.0 ASANA_BASE_URL Override for self-hosted proxies. timeout 10.0 ASANA_TIMEOUT Seconds. user_agent integrations-sdk ASANA_USER_AGENT Added to every request.","title":"Settings"},{"location":"providers/asana/#quick-call","text":"from integrations import Integrations async def new_task(): integrations = Integrations(asana={\"token\": \"...\", \"workspace_gid\": \"123\"}) task = await integrations.asana.create_task( workspace_gid=\"123\", name=\"Ship docs\", ) return task[\"gid\"] Notable actions: create_task , find_project , raw_request . Responses are auto-unwrapped so .create_task returns the Asana \"data\" payload.","title":"Quick Call"},{"location":"providers/github/","text":"GitHub Settings Field Default Env keys Notes token None GITHUB_TOKEN GITHUB_PAT GITHUB_OAUTH_TOKEN GITHUB_APP_TOKEN Required for authenticated calls. authorization_scheme Bearer GITHUB_TOKEN_TYPE Usually leave as-is. base_url https://api.github.com GITHUB_BASE_URL Point at GHES if needed. user_agent integrations-sdk GITHUB_USER_AGENT GitHub requires a UA string. timeout 10.0 GITHUB_TIMEOUT Seconds. Quick Call from integrations import Integrations async def open_issue(): integrations = Integrations(github={\"token\": \"ghp_...\"}) issue = await integrations.github.create_issue( owner=\"octocat\", repo=\"hello-world\", title=\"Docs shipped\", ) return issue[\"number\"] Highlights: repository utilities ( find_repository , create_branch ), pull-request helpers, Codespaces lifecycle, and raw_request for any endpoint. Responses keep GitHub's JSON shape; extend the provider if you need something custom.","title":"GitHub"},{"location":"providers/github/#github","text":"","title":"GitHub"},{"location":"providers/github/#settings","text":"Field Default Env keys Notes token None GITHUB_TOKEN GITHUB_PAT GITHUB_OAUTH_TOKEN GITHUB_APP_TOKEN Required for authenticated calls. authorization_scheme Bearer GITHUB_TOKEN_TYPE Usually leave as-is. base_url https://api.github.com GITHUB_BASE_URL Point at GHES if needed. user_agent integrations-sdk GITHUB_USER_AGENT GitHub requires a UA string. timeout 10.0 GITHUB_TIMEOUT Seconds.","title":"Settings"},{"location":"providers/github/#quick-call","text":"from integrations import Integrations async def open_issue(): integrations = Integrations(github={\"token\": \"ghp_...\"}) issue = await integrations.github.create_issue( owner=\"octocat\", repo=\"hello-world\", title=\"Docs shipped\", ) return issue[\"number\"] Highlights: repository utilities ( find_repository , create_branch ), pull-request helpers, Codespaces lifecycle, and raw_request for any endpoint. Responses keep GitHub's JSON shape; extend the provider if you need something custom.","title":"Quick Call"},{"location":"providers/gmail/","text":"Gmail Settings Field Default Env keys Notes token None GMAIL_TOKEN GMAIL_ACCESS_TOKEN GOOGLE_TOKEN GOOGLE_ACCESS_TOKEN Required OAuth access token. authorization_scheme Bearer GMAIL_TOKEN_TYPE Rarely overridden. base_url https://gmail.googleapis.com/gmail/v1 GMAIL_BASE_URL Change for testing stubs. user_id \"me\" GMAIL_USER_ID Override when acting for another mailbox. timeout 10.0 GMAIL_TIMEOUT Seconds. Quick Call from integrations import Integrations async def send_email(): integrations = Integrations(gmail={\"token\": \"ya29...\"}) await integrations.gmail.send_email( to=[\"ops@example.com\"], subject=\"Deploy finished\", body=\"All green.\", ) Use add_label_to_email , move_email , or raw_request when you need lower-level Gmail API access. The provider raises if no token is supplied.","title":"Gmail"},{"location":"providers/gmail/#gmail","text":"","title":"Gmail"},{"location":"providers/gmail/#settings","text":"Field Default Env keys Notes token None GMAIL_TOKEN GMAIL_ACCESS_TOKEN GOOGLE_TOKEN GOOGLE_ACCESS_TOKEN Required OAuth access token. authorization_scheme Bearer GMAIL_TOKEN_TYPE Rarely overridden. base_url https://gmail.googleapis.com/gmail/v1 GMAIL_BASE_URL Change for testing stubs. user_id \"me\" GMAIL_USER_ID Override when acting for another mailbox. timeout 10.0 GMAIL_TIMEOUT Seconds.","title":"Settings"},{"location":"providers/gmail/#quick-call","text":"from integrations import Integrations async def send_email(): integrations = Integrations(gmail={\"token\": \"ya29...\"}) await integrations.gmail.send_email( to=[\"ops@example.com\"], subject=\"Deploy finished\", body=\"All green.\", ) Use add_label_to_email , move_email , or raw_request when you need lower-level Gmail API access. The provider raises if no token is supplied.","title":"Quick Call"},{"location":"providers/google-calendar/","text":"Google Calendar Settings Field Default Env keys Notes token None GOOGLE_CALENDAR_ACCESS_TOKEN GOOGLE_CALENDAR_TOKEN GOOGLE_TOKEN GOOGLE_ACCESS_TOKEN OAuth token with calendar scopes. authorization_scheme Bearer GOOGLE_CALENDAR_AUTHORIZATION_SCHEME Adjust only for custom auth. base_url https://www.googleapis.com/calendar/v3 GOOGLE_CALENDAR_BASE_URL Override for mocks. timeout 10.0 GOOGLE_CALENDAR_TIMEOUT Seconds. user_agent integrations-sdk GOOGLE_CALENDAR_USER_AGENT Optional. default_calendar_id None GOOGLE_CALENDAR_DEFAULT_CALENDAR_ID Used when actions omit the calendar. Quick Call from integrations import Integrations async def block_time(): integrations = Integrations(google_calendar={\"token\": \"ya29...\"}) event = await integrations.google_calendar.find_or_create_event( calendar_id=\"primary\", summary=\"Pairing session\", start_time=\"2024-05-01T16:00:00Z\", end_time=\"2024-05-01T17:00:00Z\", ) return event[\"id\"] Calendar utilities include find_busy_periods , quick_add_event , and raw_request for anything outside the high-level surface. JSON errors bubble up with readable messages.","title":"Google Calendar"},{"location":"providers/google-calendar/#google-calendar","text":"","title":"Google Calendar"},{"location":"providers/google-calendar/#settings","text":"Field Default Env keys Notes token None GOOGLE_CALENDAR_ACCESS_TOKEN GOOGLE_CALENDAR_TOKEN GOOGLE_TOKEN GOOGLE_ACCESS_TOKEN OAuth token with calendar scopes. authorization_scheme Bearer GOOGLE_CALENDAR_AUTHORIZATION_SCHEME Adjust only for custom auth. base_url https://www.googleapis.com/calendar/v3 GOOGLE_CALENDAR_BASE_URL Override for mocks. timeout 10.0 GOOGLE_CALENDAR_TIMEOUT Seconds. user_agent integrations-sdk GOOGLE_CALENDAR_USER_AGENT Optional. default_calendar_id None GOOGLE_CALENDAR_DEFAULT_CALENDAR_ID Used when actions omit the calendar.","title":"Settings"},{"location":"providers/google-calendar/#quick-call","text":"from integrations import Integrations async def block_time(): integrations = Integrations(google_calendar={\"token\": \"ya29...\"}) event = await integrations.google_calendar.find_or_create_event( calendar_id=\"primary\", summary=\"Pairing session\", start_time=\"2024-05-01T16:00:00Z\", end_time=\"2024-05-01T17:00:00Z\", ) return event[\"id\"] Calendar utilities include find_busy_periods , quick_add_event , and raw_request for anything outside the high-level surface. JSON errors bubble up with readable messages.","title":"Quick Call"},{"location":"providers/google-docs/","text":"Google Docs Settings Field Default Env keys Notes token None GOOGLE_DOCS_ACCESS_TOKEN GOOGLE_DOCS_TOKEN GOOGLE_TOKEN GOOGLE_ACCESS_TOKEN OAuth token with docs scope. authorization_scheme Bearer GOOGLE_DOCS_AUTHORIZATION_SCHEME Change only for custom auth. base_url https://docs.googleapis.com/v1 GOOGLE_DOCS_BASE_URL Override for mocks. timeout 10.0 GOOGLE_DOCS_TIMEOUT Seconds. user_agent integrations-sdk GOOGLE_DOCS_USER_AGENT Optional. Quick Call from integrations import Integrations async def append_text(): integrations = Integrations(google_docs={\"token\": \"ya29...\"}) await integrations.google_docs.append_text_to_document( document_id=\"1A2B...\", text=\"Release notes updated.\", ) Use helpers like insert_text , find_and_replace_text , format_text , or fall back to raw_request for uncommon operations.","title":"Google Docs"},{"location":"providers/google-docs/#google-docs","text":"","title":"Google Docs"},{"location":"providers/google-docs/#settings","text":"Field Default Env keys Notes token None GOOGLE_DOCS_ACCESS_TOKEN GOOGLE_DOCS_TOKEN GOOGLE_TOKEN GOOGLE_ACCESS_TOKEN OAuth token with docs scope. authorization_scheme Bearer GOOGLE_DOCS_AUTHORIZATION_SCHEME Change only for custom auth. base_url https://docs.googleapis.com/v1 GOOGLE_DOCS_BASE_URL Override for mocks. timeout 10.0 GOOGLE_DOCS_TIMEOUT Seconds. user_agent integrations-sdk GOOGLE_DOCS_USER_AGENT Optional.","title":"Settings"},{"location":"providers/google-docs/#quick-call","text":"from integrations import Integrations async def append_text(): integrations = Integrations(google_docs={\"token\": \"ya29...\"}) await integrations.google_docs.append_text_to_document( document_id=\"1A2B...\", text=\"Release notes updated.\", ) Use helpers like insert_text , find_and_replace_text , format_text , or fall back to raw_request for uncommon operations.","title":"Quick Call"},{"location":"providers/google-drive/","text":"Google Drive Settings Field Default Env keys Notes token None GOOGLE_DRIVE_ACCESS_TOKEN GOOGLE_DRIVE_TOKEN GOOGLE_TOKEN GOOGLE_ACCESS_TOKEN OAuth token with Drive scope. authorization_scheme Bearer GOOGLE_DRIVE_AUTHORIZATION_SCHEME Change only if you alter auth headers. base_url https://www.googleapis.com/drive/v3 GOOGLE_DRIVE_BASE_URL Core API endpoint. upload_base_url https://www.googleapis.com/upload/drive/v3 GOOGLE_DRIVE_UPLOAD_BASE_URL Used automatically for uploads. timeout 10.0 GOOGLE_DRIVE_TIMEOUT Seconds. user_agent integrations-sdk GOOGLE_DRIVE_USER_AGENT Optional. default_drive_id None GOOGLE_DRIVE_DEFAULT_DRIVE_ID Set when you work inside a shared drive. default_parent_id None GOOGLE_DRIVE_DEFAULT_PARENT_ID Used when actions omit a parent folder. Quick Call from integrations import Integrations async def upload_text(): integrations = Integrations(google_drive={\"token\": \"ya29...\"}) file = await integrations.google_drive.create_file_from_text( name=\"release-notes.txt\", content=\"Docs shipped.\", mime_type=\"text/plain\", ) return file[\"id\"] Drive actions cover uploads, conversions, sharing, and lookup helpers. Reach for raw_request to call any endpoint directly.","title":"Google Drive"},{"location":"providers/google-drive/#google-drive","text":"","title":"Google Drive"},{"location":"providers/google-drive/#settings","text":"Field Default Env keys Notes token None GOOGLE_DRIVE_ACCESS_TOKEN GOOGLE_DRIVE_TOKEN GOOGLE_TOKEN GOOGLE_ACCESS_TOKEN OAuth token with Drive scope. authorization_scheme Bearer GOOGLE_DRIVE_AUTHORIZATION_SCHEME Change only if you alter auth headers. base_url https://www.googleapis.com/drive/v3 GOOGLE_DRIVE_BASE_URL Core API endpoint. upload_base_url https://www.googleapis.com/upload/drive/v3 GOOGLE_DRIVE_UPLOAD_BASE_URL Used automatically for uploads. timeout 10.0 GOOGLE_DRIVE_TIMEOUT Seconds. user_agent integrations-sdk GOOGLE_DRIVE_USER_AGENT Optional. default_drive_id None GOOGLE_DRIVE_DEFAULT_DRIVE_ID Set when you work inside a shared drive. default_parent_id None GOOGLE_DRIVE_DEFAULT_PARENT_ID Used when actions omit a parent folder.","title":"Settings"},{"location":"providers/google-drive/#quick-call","text":"from integrations import Integrations async def upload_text(): integrations = Integrations(google_drive={\"token\": \"ya29...\"}) file = await integrations.google_drive.create_file_from_text( name=\"release-notes.txt\", content=\"Docs shipped.\", mime_type=\"text/plain\", ) return file[\"id\"] Drive actions cover uploads, conversions, sharing, and lookup helpers. Reach for raw_request to call any endpoint directly.","title":"Quick Call"},{"location":"providers/google-sheets/","text":"Google Sheets Settings Field Default Env keys Notes token None GOOGLE_SHEETS_ACCESS_TOKEN GOOGLE_SHEETS_TOKEN GOOGLE_TOKEN GOOGLE_ACCESS_TOKEN OAuth token with Sheets scope. authorization_scheme Bearer GOOGLE_SHEETS_AUTHORIZATION_SCHEME Adjust only if headers must change. base_url https://sheets.googleapis.com/v4/spreadsheets GOOGLE_SHEETS_BASE_URL API base. timeout 10.0 GOOGLE_SHEETS_TIMEOUT Seconds. user_agent integrations-sdk GOOGLE_SHEETS_USER_AGENT Optional. default_spreadsheet_id None GOOGLE_SHEETS_DEFAULT_SPREADSHEET_ID GOOGLE_SHEETS_SPREADSHEET_ID Used when actions omit the spreadsheet. Quick Call from integrations import Integrations async def append_row(): integrations = Integrations(google_sheets={\"token\": \"ya29...\"}) await integrations.google_sheets.create_spreadsheet_row( spreadsheet_id=\"1A2B...\", worksheet_title=\"Summary\", values=[\"Docs\", \"Shipped\"], ) Sheets helpers cover formatting, lookups, conditional rules, and bulk updates. raw_request remains available for niche endpoints.","title":"Google Sheets"},{"location":"providers/google-sheets/#google-sheets","text":"","title":"Google Sheets"},{"location":"providers/google-sheets/#settings","text":"Field Default Env keys Notes token None GOOGLE_SHEETS_ACCESS_TOKEN GOOGLE_SHEETS_TOKEN GOOGLE_TOKEN GOOGLE_ACCESS_TOKEN OAuth token with Sheets scope. authorization_scheme Bearer GOOGLE_SHEETS_AUTHORIZATION_SCHEME Adjust only if headers must change. base_url https://sheets.googleapis.com/v4/spreadsheets GOOGLE_SHEETS_BASE_URL API base. timeout 10.0 GOOGLE_SHEETS_TIMEOUT Seconds. user_agent integrations-sdk GOOGLE_SHEETS_USER_AGENT Optional. default_spreadsheet_id None GOOGLE_SHEETS_DEFAULT_SPREADSHEET_ID GOOGLE_SHEETS_SPREADSHEET_ID Used when actions omit the spreadsheet.","title":"Settings"},{"location":"providers/google-sheets/#quick-call","text":"from integrations import Integrations async def append_row(): integrations = Integrations(google_sheets={\"token\": \"ya29...\"}) await integrations.google_sheets.create_spreadsheet_row( spreadsheet_id=\"1A2B...\", worksheet_title=\"Summary\", values=[\"Docs\", \"Shipped\"], ) Sheets helpers cover formatting, lookups, conditional rules, and bulk updates. raw_request remains available for niche endpoints.","title":"Quick Call"},{"location":"providers/hubspot/","text":"HubSpot Settings Field Default Env keys Notes access_token None HUBSPOT_ACCESS_TOKEN HUBSPOT_TOKEN HUBSPOT_PRIVATE_APP_TOKEN Required private app token. base_url https://api.hubapi.com HUBSPOT_BASE_URL Override for EU or custom domains. timeout 15.0 HUBSPOT_TIMEOUT Seconds. user_agent integrations-sdk HUBSPOT_USER_AGENT Optional. Quick Call from integrations import Integrations async def upsert_contact(): integrations = Integrations(hubspot={\"access_token\": \"pat-...\"}) contact = await integrations.hubspot.create_or_update_contact( identifier=\"user@example.com\", properties={\"firstname\": \"Docs\"}, ) return contact[\"id\"] Choose from CRM helpers for contacts, companies, deals, custom objects, marketing uploads, or fall back to raw_request when exploring beta features.","title":"HubSpot"},{"location":"providers/hubspot/#hubspot","text":"","title":"HubSpot"},{"location":"providers/hubspot/#settings","text":"Field Default Env keys Notes access_token None HUBSPOT_ACCESS_TOKEN HUBSPOT_TOKEN HUBSPOT_PRIVATE_APP_TOKEN Required private app token. base_url https://api.hubapi.com HUBSPOT_BASE_URL Override for EU or custom domains. timeout 15.0 HUBSPOT_TIMEOUT Seconds. user_agent integrations-sdk HUBSPOT_USER_AGENT Optional.","title":"Settings"},{"location":"providers/hubspot/#quick-call","text":"from integrations import Integrations async def upsert_contact(): integrations = Integrations(hubspot={\"access_token\": \"pat-...\"}) contact = await integrations.hubspot.create_or_update_contact( identifier=\"user@example.com\", properties={\"firstname\": \"Docs\"}, ) return contact[\"id\"] Choose from CRM helpers for contacts, companies, deals, custom objects, marketing uploads, or fall back to raw_request when exploring beta features.","title":"Quick Call"},{"location":"providers/notion/","text":"Notion Settings Field Default Env keys Notes token None NOTION_TOKEN NOTION_INTEGRATION_TOKEN Required integration secret. version 2022-06-28 NOTION_VERSION NOTION_API_VERSION Overrides API version header. base_url https://api.notion.com/v1 NOTION_BASE_URL Override for proxy setups. timeout 10.0 NOTION_TIMEOUT Seconds. user_agent integrations-sdk NOTION_USER_AGENT Optional. Quick Call from integrations import Integrations async def add_page(): integrations = Integrations(notion={\"token\": \"secret_...\"}) page = await integrations.notion.create_page( parent_database_id=\"abc123\", title=\"Docs Launch\", ) return page[\"id\"] Other helpers: update_database_item , add_content_to_page , add_comment , plus raw_request for experimental APIs.","title":"Notion"},{"location":"providers/notion/#notion","text":"","title":"Notion"},{"location":"providers/notion/#settings","text":"Field Default Env keys Notes token None NOTION_TOKEN NOTION_INTEGRATION_TOKEN Required integration secret. version 2022-06-28 NOTION_VERSION NOTION_API_VERSION Overrides API version header. base_url https://api.notion.com/v1 NOTION_BASE_URL Override for proxy setups. timeout 10.0 NOTION_TIMEOUT Seconds. user_agent integrations-sdk NOTION_USER_AGENT Optional.","title":"Settings"},{"location":"providers/notion/#quick-call","text":"from integrations import Integrations async def add_page(): integrations = Integrations(notion={\"token\": \"secret_...\"}) page = await integrations.notion.create_page( parent_database_id=\"abc123\", title=\"Docs Launch\", ) return page[\"id\"] Other helpers: update_database_item , add_content_to_page , add_comment , plus raw_request for experimental APIs.","title":"Quick Call"},{"location":"providers/slack/","text":"Slack Settings Field Default Env keys Notes token None SLACK_BOT_TOKEN SLACK_TOKEN SLACK_USER_TOKEN User or bot token required. base_url https://slack.com/api SLACK_BASE_URL Override for testing proxies. user_agent integrations-sdk SLACK_USER_AGENT Optional. timeout 10.0 SLACK_TIMEOUT Seconds. Quick Call from integrations import Integrations async def post_message(): integrations = Integrations(slack={\"token\": \"xoxb-...\"}) await integrations.slack.send_channel_message( channel=\"#docs\", text=\"Documentation shipped.\", ) You also get helpers for DMs, reminders, channel administration, and profile status management. Use raw_request when you need a Slack API that is not wrapped yet.","title":"Slack"},{"location":"providers/slack/#slack","text":"","title":"Slack"},{"location":"providers/slack/#settings","text":"Field Default Env keys Notes token None SLACK_BOT_TOKEN SLACK_TOKEN SLACK_USER_TOKEN User or bot token required. base_url https://slack.com/api SLACK_BASE_URL Override for testing proxies. user_agent integrations-sdk SLACK_USER_AGENT Optional. timeout 10.0 SLACK_TIMEOUT Seconds.","title":"Settings"},{"location":"providers/slack/#quick-call","text":"from integrations import Integrations async def post_message(): integrations = Integrations(slack={\"token\": \"xoxb-...\"}) await integrations.slack.send_channel_message( channel=\"#docs\", text=\"Documentation shipped.\", ) You also get helpers for DMs, reminders, channel administration, and profile status management. Use raw_request when you need a Slack API that is not wrapped yet.","title":"Quick Call"}]}